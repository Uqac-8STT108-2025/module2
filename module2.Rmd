---
title: " Module2 \n "
author: " 1. Wilson FOTSING   \n  

          2. Wilfried Armel N'GUESSAN   \n   
          
          3. Vamoussa DIABATE   \n  
          
          4.  Laurent Fabrice NGWE   \n
          
          5. Iantsa Marie-Anne RANDRIANARIVONY \n \n "  
          
date: " **date** : `r Sys.Date()` 
"
output: html_document
---

```{r libairies, include=FALSE}
#install.packages("skimr")
library(tidyverse)
library(knitr)
```


## Statistiques descriptives

### Exercice 1

calculons la moyenne et variance, que remarquez-vous? Pourquoi?

On remarque que les valeurs de la moyenne et de la variance calculées sur un échantillon ne sont pas égales aux valeurs théoriques (moyenne=0 et variance=1).

pour n=100, Ces résultats s'écartent de ceux attendus à cause du biais d'échantillonage.

```{r serie_norm}
set.seed(42)
x <- rnorm(100)

#Calculons la moyenne

mean_x <- mean(x)

#Calculons la variance

var_x <- var(x)

#Les résultats

cat("Moyenne :", mean_x, "\n")
cat("Variance :", var_x, "\n")
```
Augmenter le nombre d’observation dans la fonction rnorm() qui génère des données d’une loi normale, que se passe t-il?

En augmentant le nombre d'observation a n=10000 nous remarquons que les résultats sont très proches des valeurs théoriques(moyenne=0 et variance=1).

```{r augmentation_taille}
set.seed(123)
x_large <- rnorm(10000, mean = 0, sd = 1)

#Calcul de la moyenne

mean_large <- mean(x_large)

#Calcul de la variance

var_large <- var(x_large)

#Affichage des résultats

cat("Moyenne avec grand échantillon :", mean_large, "\n")
cat("Variance avec grand échantillon :", var_large, "\n")
```

### Exercice 2

Construire une fonction qui permet de représenter la distribution d’une série de données. 

```{r plot_distribution}
#la fonction

plot_distribution <- function(data, variable, title = "Distribution d'une série ", color = "gray")
  
  #Création du graphique
  
  ggplot(data, aes_string(x = variable)) +
  geom_histogram(aes(y = ..density..), 
                   binwidth = 0.3,         # Largeur des barres
                   fill = color,           #Couleur des barres
                   alpha = 0.6,            #Transparence des barres
                   color = "black") +      #Bordure des barres
    geom_density(color = "blue", size = 1) + #Courbe de densité
    labs(title = title, x = variable, y = "Densite") + #Titre et étiquettes des axes
    theme_minimal()                         #Thème visuel simple

```

Application de la fonction à une colonne de iris

```{r application_iris}
# Appliquer la fonction à la  colonne "Sepal.Width" 
plot_distribution(iris, "Sepal.Width", 
                  title = "Distribution de la largeur des sépales", 
                  color = "gray")
```
### Exercice 3
cor(x,y)=0,1881861
Cette valeur exprime une faible corrélation positive linéaire entre x et y.


```{r correlation_lineaire}
set.seed(123)  

x <- rnorm(100)  #Générer un échantillon de 100 points suivant une loi normale

y <- x * x

#Calcul de la corrélation

correlation <- cor(x, y)

#les résultats

cat("La corrélation entre x et y est :", correlation, "\n")
```


### Exercice 4


```{r dataset}
vehicule <- read.csv("Dataset 1.csv")
head(vehicule)
```
```{r colonnes}
glimpse(vehicule)
cat("\n nbre valeurs manquantes : " , sum(is.na(vehicule)))
```


Nous constatons ici que toutes les valeurs manquantes (NA) se retrouvent dans la variable COMMUTE_DISTANCE.
```{r résumé}
summary(vehicule)
```


### Exercice 5

```{r fonction_skim}
library(skimr)
skim(vehicule)%>%
  kable()
```

## Détection de bruit et données abbérantes

### Exercice 1

```{r outliers}
outliers <- function(dataset) {
  # On enleve  les valeurs manquantes pour éviter des erreurs
  data <- na.omit(dataset)

  Q1 <- quantile(data, 0.25)
  Q3 <- quantile(data, 0.75)
  IQR <- Q3-Q1
  
  # Calcul des bornes
  borne_inf <- Q1 - 1.5 * IQR
  borne_sup <- Q3 + 1.5 * IQR
  
  # Identification des outliers
  outliers <- data[data < borne_inf | data > borne_sup]
  
  #print(outliers)
  return (outliers) #utilisation explicite de return pour améliorer la lisibilité du code.
}

# Test avec la variable x
set.seed(42) #pour la reproductibilité
x <- c(-5, rnorm(100), 6)
valeurs_extremes <- outliers(x)
cat("valeurs extremes :" , valeurs_extremes)

```


### Exercice 2 

Le dataset dataset_pratique.csv est inexistant.


## Visualisation

### Exercice 1
  On obtient un graphique vide en mentionnant que le jeu de donnée mpg.
  Il y a 234 observations et 11 colonnes dans la base de donnée mpg.
  La variable 'drv' représente le type de transmission où f représente la traction avant et r la traction arrière.
  Le nuage de points entre la variable 'class' et la variable 'drv' est inutile car il n'y a pas de relation entre ces deux variables.
```{r visualisation-mpg}

#Chargement de la librairie ggplot2
library(ggplot2)

#Exécution de la commande ggplot
ggplot(data=mpg)  

#Pour savoir le nombre de lignes et de colonnes
nrow(mpg)
ncol(mpg)


#Création d'un nuage de points entre la variable 'hwy' et la variable 'cyl'
hwy_cyl<-ggplot(mpg,aes(x=hwy,y=cyl))+
  geom_point() +
  labs(title='Relation entre les kilomètres de routes et le nombre de cylindre ')+
  xlab('Les kilomètres de routes par gallon')+
  ylab('Le nombre de cylindre')
hwy_cyl

#Création d 'un nuage de points entre la variable 'class' et la variable 'drv' 
class_drv<-ggplot(mpg,aes(x=class,y=drv))+
  geom_point()+
  labs(title='Relation entre les classes et le type de transmission')+
  xlab('Les types de voiture(class)')+
  ylab('Le type de transmission(drv)')
class_drv
```



### Exercice 2
Quand on met la couleur dans l'esthétique, R le considère comme une variable dans les données, donc pour obtenir la couleur bleue il faut le mettre en dehors de l'esthétique.
Les variables catégoriques sont: manufacturer, model,trans,fl,drv et class puis les variables continues sont: displ,year,cyl,cty et hwy.
On peut voir ces informations en exécutant View(mpg) ou glimpse(mpg).

En mappant la même variable à plusieurs esthétiques, le graphique sera difficile à interpréter.

L'esthétique du trait (stroke) sert à modifier la largeur de la bordure des points pour un nuage de points.

En associant l'esthétique à une condition, on obtient une visualisation qui montre les variables qui respectent cette condition (true) et celles qui ne respectent pas cette condition(false).

```{r exo2-visualisation}
ggplot(data=mpg)+
  geom_point(mapping=aes(x=displ,y=hwy),color="blue")

#Mappez une même variable à plusieurs esthétiques
ggplot(data=mpg)+
  geom_point(mapping=aes(x=displ,y=hwy,color=year,alpha=year))

#Associer une esthétique avec autre chose qu'un nom de variable
ggplot(data=mpg)+
  geom_point(mapping=aes(x=displ,y=hwy,color=displ<5))
```

### Exercice 3

Les cellules vides du tracé avec facet_grid(drv ~ cyl) signifient qu'il n'existe dans notre jeu de données aucune correspondance entre cette valeur de drv et celle de cyl.
Cette visualisation met en lumière les différentes cylindré(cyl) existantes dans notre dataset pour chacune des tractions (4,f,r).


